-parsing
    -optional arguments
        -insert in parser:
            -parse param list
            -parse generic param or arg list
            -struct parsing with leading optional argument
        -insert in printer:
            -reverse_print_func_params
    -ternaries
    -varargs
    -named parameters?
    -tuples?
    -quick arrays
    -dynamic arrays
    -lambdas
    -switch, reflect, do while
    -unions
    -meta # parsing
        -ast nodes and parse branch
        -paste{...} special function
    -modifiers
    -exceptions: !: syntax, try catch
    -concepts, inheritance
    -special functions
        -sizeof
        -typeof
        -offsetof
        -alignof    ???
        -assert
        -cast       ???

-type system
   -add error function that goes through file until it reaches the ast node at fault
   -add type declarations while parsing
        -namespaces
        -typedefs
        -structs
        -functions
        -generic structs
        -generic functions
   -do a complete pass over the ast to
        -add variable declarations (disambiguate with expressions)
   -go through type tree and
        -resolve function parameter and return types
        -resolve generic parameters
        -fix scoping of (partially) specialized generics
        -resolve "auto" type inference
        -deduce the size for each type
        -disambiguate generic scopes between generic struct decl and inst
   -do a second ast pass to resolve
        -variable accesses
        -array accesses
        -(overloaded)(generic) function calls
        -generic struct scopes
    -

-backends
    -decide whether we need an additional intermediate representation before bytecode
    -bytecode generator
    -optimizing bytecode generator (inlining, compile time evaluation, unrolling, etc.)
    -bytecode interpreter
    -bytecode to C backend
    -bytecode to LLVM backend
    -bytecode to to x86 Assembly
    -bytecode to to x64 Assembly